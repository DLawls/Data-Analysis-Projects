# -*- coding: utf-8 -*-
"""Kmeans2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1N8rCcabW71XZDEKQ3TaIWcZin0x0Y8Sr
"""

# Import libraries
import pandas as pd
import numpy as np
import random as rd
import matplotlib.pyplot as plt

# Read File
data=pd.read_csv("DMV302_Assessment_2_HouseholdWealth.csv")
print(data.shape)
data.head

# Visualise data points
X = data[["household_total_assets","annual_household_income"]]
plt.scatter(X["annual_household_income"],X["household_total_assets"],c='black')
plt.xlabel('annual_household_income')
plt.ylabel('household_total_assets (In Thousands)')
plt.show()

# Set number of clusters
K=3

# As I can't see much central tendencies, we will select random observation as centroids
Centroids = (X.sample(n=K))
plt.scatter(X["annual_household_income"],X["household_total_assets"],c='black')
plt.scatter(Centroids["annual_household_income"],Centroids["household_total_assets"],c='red')
plt.xlabel('Annual Household Income')
plt.ylabel('Household Total Assets (In Thousands)')
plt.show()
# Read dots represent the 3 centroids

# K-Means Clustering Algorithm Implementation
# Assign all the points to the closest cluster centroid
# Recompute centroids of newly formed clusters
# Repeat until difference is 0

diff = 1
j=0

while(diff!=0):
    XD=X
    i=1
    for index1,row_c in Centroids.iterrows():
      #Euclidean Distance
        ED=[]
        for index2,row_d in XD.iterrows():
            d1=(row_c["annual_household_income"]-row_d["annual_household_income"])**2
            d2=(row_c["household_total_assets"]-row_d["household_total_assets"])**2
            d=np.sqrt(d1+d2)
            ED.append(d)
        X[i]=ED
        i=i+1

    C=[]
    for index,row in X.iterrows():
        min_dist=row[1]
        pos=1
        for i in range(K):
            if row[i+1] < min_dist:
                min_dist = row[i+1]
                pos=i+1
        C.append(pos)
    X["Cluster"]=C
    Centroids_new = X.groupby(["Cluster"]).mean()[["household_total_assets","annual_household_income"]]
    if j == 0:
        diff=1
        j=j+1
    else:
        diff = (Centroids_new['household_total_assets'] - Centroids['household_total_assets']).sum() + (Centroids_new['annual_household_income'] - Centroids['annual_household_income']).sum()
        print(diff.sum())
    Centroids = X.groupby(["Cluster"]).mean()[["household_total_assets","annual_household_income"]]

# Print Final Centroids
print(Centroids)

# Visualise Clusters
color=['blue','green','purple', 'Yellow', 'Orange', 'cyan', 'brown', 'gray', 'lightgreen', 'violet']
for k in range(K):
    data=X[X["Cluster"]==k+1]
    plt.scatter(data["annual_household_income"],data["household_total_assets"],c=color[k])
plt.scatter(Centroids["annual_household_income"],Centroids["household_total_assets"],c='red')
plt.xlabel('annual_household_income')
plt.ylabel('household_total_assets (In Thousands)')
plt.show()

# Function to find euclidean distance between two points 
def findDistance(point1, point2):
    
    eucDis = 0
    for i in range(len(point1)):
        eucDis = eucDis + (point1[i] - point2[i])**2
 
    return eucDis**0.5

# Function to calcualte Dunn Index
def calcDunnIndex(points, cluster):
    
    numer = float('inf')
    for c in cluster: 
        for t in cluster: 
          
            if (t == c).all(): continue 
            ndis = findDistance(t, c)
            numer = min(numer, ndis) 
            
    denom = 0
    for c in cluster: 
        for p in points: 
            for t in points: 
                if (t == p).all(): continue 
                ddis = findDistance(t, p)
                denom = max(denom, ddis)
                
    return numer/denom

# Function to calculate Inertia
def calcInertia(points, clusters):
        
        cluster_sum_of_squares_points_to_clusters = 0    

        for centroid, cluster_points in clusters.items():            
            for cluster_point in cluster_points:
                euclidean_norm_distance = points.get_euclidean_distance(cluster_point, centroid)
                euclidean_norm_distance_squared = euclidean_norm_distance**2

                cluster_sum_of_squares_points_to_clusters += euclidean_norm_distance_squared
        return cluster_sum_of_squares_points_to_clusters